from typing import Dict, Tuple, Type, List, Optional, Callable
from shared import Manufacturer, AttackType, DroneTargetInfo
from .base_attack_script import BaseAttackScript

Key = Tuple[Manufacturer, str]  # (Manufacturer, model-string)

class AttackFactory:
    """Registry mapping (manufacturer, model) & AttackType -> Attack class (type)."""
    def __init__(self):
        self._registry: Dict[Key, Dict[AttackType, Type[BaseAttackScript]]] = {}

    def register(self, manufacturer: Manufacturer, models: List[str],
                 attack_types: List[AttackType], attack_cls: Type[BaseAttackScript]) -> None:
        for model in models:
            key = (manufacturer, model)
            self._registry.setdefault(key, {})
            for atype in attack_types:
                self._registry[key][atype] = attack_cls

    def get_supported_attacks(self, manufacturer: Manufacturer, model: str) -> List[AttackType]:
        return list(self._registry.get((manufacturer, model), {}).keys())

    def create(self, manufacturer: Manufacturer, model: str, attack_type: AttackType,
               info: DroneTargetInfo) -> Optional[BaseAttackScript]:
        attack_cls = self._registry.get((manufacturer, model), {}).get(attack_type)
        return attack_cls(info) if attack_cls else None

_factory = AttackFactory()

def get_attack_factory() -> AttackFactory:
    return _factory

def register_attack(manufacturer: Manufacturer, models: List[str],
                    attack_types: List[AttackType]) -> Callable[[Type[BaseAttackScript]], Type[BaseAttackScript]]:
    """Decorator to register an attack class for manufacturer/models/attack_types."""
    def _decorator(cls: Type[BaseAttackScript]) -> Type[BaseAttackScript]:
        _factory.register(manufacturer, models, attack_types, cls)
        return cls
    return _decorator
